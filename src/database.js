import * as config from "./config";
import * as constants from "./constants";
import * as db from "./aws-db";
import {encodeEmptyStr} from "./util";


export const init = () => {
    db.init();
};

export const getTracks = () => {
    return db.getItems(constants.tracks_path);
};

export const getCounts = () => {
    return db.getItems(constants.counts_path);
};

// rating methods
export const update_rating_data = async (userId, trackId, ratingData) => {
    // two places this needs to be set
    // first check if this is first rating
    let oldRatingData = await db.getItem(constants.ratings_path, trackId, userId);
    // encode any empty strings in rating data
    ratingData = encodeEmptyStr(ratingData);
    // set in ratings table
    let expr = "SET #userId = :ratingData";
    let exprNames = {"#userId": userId};
    let exprValues = {":ratingData": ratingData};
    await db.updateItem(constants.ratings_path, trackId, expr, exprNames, exprValues);

    expr = "SET ratings.#trackId = :ratingData";
    exprNames = {"#trackId": trackId};
    exprValues = {":ratingData": ratingData};

    await db.updateItem(constants.users_path, userId,  expr, exprNames, exprValues);

    if (!oldRatingData) {
        // first time its been rated, update the rating count
        // (since its written
        await increment_count(constants.counts_path, trackId, constants.tracks_rating_count);
    }
};

export const update_track_count = async (trackId, countName) => {
    let expr = "set " + countName + " = " + countName + " + :vale";
    let exprValues = {":vale": 1};
    await db.updateItem(constants.counts_path, trackId, expr, null, exprValues);
};

export const save_poll_data = async (oldPollData, pollData) => {
    if (oldPollData.other !== pollData.other ) {
        // retreive full list
        let otherList = await db.getItem(constants.poll_other_path, config.poll_other, config.poll_answers);
        let answers = otherList.answers;

        let modified = false;
        if (oldPollData.other !== null && oldPollData.other !== "") {
            answers = answers.filter(value => { return value !== oldPollData.other});
            modified = true;
        }
        // add new
        if (pollData.other !== null && pollData.other !== "") {
            answers.push(pollData.other);
            modified = true;
        }

        if (modified) {
            const expr = "SET #answers = :answers";
            const exprNames = {"#answers": config.poll_answers};
            const exprValues = {":answers": answers};
            await db.updateItem(constants.poll_other_path, config.poll_other, expr, exprNames, exprValues);
        }
    }

    // update checked values
    if (Object.keys(oldPollData.checked.sort().toString() !== pollData.checked.sort().toString() )) {
        // remove old counts
        oldPollData.checked.forEach(async value => {
            await decrement_count(constants.poll_path, value, "count");
        });
        // select new counts
        pollData.checked.forEach(async value => {
            await increment_count(constants.poll_path, value, "count");
        });
    }
};

export const set_rating = async (userId, trackId, ratingData) => {
    let data = await update_rating_data(userId, trackId, ratingData);
    await increment_count(constants.counts_path, trackId, constants.tracks_rating_count);
    return data;
};

export const update_track_listen_time = async (userId, trackId, listenTime, oldData) => {
    let newData = {
        listenTime: listenTime,
        timeStamp: Date.now(),
        ...oldData
    };
    await update_rating_data(userId, trackId, newData);
    await update_track_count(trackId, constants.tracks_stop_count);
};

// user methods
export const update_user = async (userId, userData) => {
    return await db.setItem(constants.users_path, userId, cleanUrls(userData));
};

const cleanUrls = userData => {
    // do deep clone first
    let updatedUserData = JSON.parse(JSON.stringify(userData));
    // clear out signed urls generated by aws
    updatedUserData.playlist.forEach(playlistEntry => {
        delete playlistEntry["artwork_url"];
        delete playlistEntry["song_url"];
    });
    return updatedUserData
};

export const fetch_user = async (userId) => {
    return await db.getItem(constants.users_path, userId);
};


export const fetch_reward_counts = async () => {
    let reward_count = await db.getItem(constants.counts_path, constants.reward_count);
    return reward_count.count;
};

export const increment_reward_count = async () => {
    await increment_count(constants.counts_path, constants.reward_count);
};

export const increment_count = async (table, id, path) => {
    let expr = "SET #path = if_not_exists(#path, :start) + :value";
    let exprNames = {"#path": path};
    let exprValues = {":start": 0, ":value": 1};
    await db.updateItem(table, id, expr, exprNames, exprValues);
};

export const decrement_count = async (table, id, path) => {
    let expr = "SET #path = if_not_exists(#path, :start) - :value";
    let exprNames = {"#path": path};
    let exprValues = {":start": 0, ":value": 1};
    await db.updateItem(table, id, expr, exprNames, exprValues);
};


// used to update track duration data, maybe remove later and replace with aws function
export const set_track = async (track) => {
    await db.setItem(constants.tracks_path, track.id, track);
};

