import * as config from "../config";
import * as constants from "../constants";
import * as db from "./local-db";

export const init = () => {
    db.init();
};

export const getTracks = () => {
    return db.getItems(constants.tracks_path);
};

export const getCounts = () => {
    return db.getItems(constants.counts_path);
};

// rating methods
export const update_rating_data = async (userId, trackId, ratingData) => {
    let oldRatingData = undefined;
    let trackRating = await db.getItem(constants.ratings_path, trackId);
    if (trackRating !== undefined && userId in trackRating) {
        oldRatingData = trackRating[userId];
    }
    await db.updateItem(constants.ratings_path, trackId, userId, ratingData);
    await db.updateItem(constants.users_path, userId, trackId, ratingData);
    if (!oldRatingData) {
        // first time its been rated, update the rating count
        // (since its written
        await increment_count(constants.counts_path, trackId, constants.tracks_rating_count);
    }
};

export const update_track_count = async (trackId, countName) => {
    let countValue = db.getItem(constants.counts_path, trackId, countName);
    await db.updateItem(constants.counts_path, trackId, countName, countValue + 1);
};

export const save_poll_data = async (oldPollData, pollData) => {
    if (oldPollData.other !== pollData.other ) {
        // retreive full list
        let otherList = await db.getItem(constants.poll_other_path, config.poll_other, config.poll_answers);
        let answers = otherList.answers;

        let modified = false;
        if (oldPollData.other !== null && oldPollData.other !== "") {
            answers = answers.filter(value => { return value !== oldPollData.other});
            modified = true;
        }
        // add new
        if (pollData.other !== null && pollData.other !== "") {
            answers.push(pollData.other);
            modified = true;
        }

        if (modified) {
            await db.updateItem(constants.poll_other_path, config.poll_other, config.poll_answers, answers);
        }
    }

    // update checked values
    if (Object.keys(oldPollData.checked.sort().toString() !== pollData.checked.sort().toString() )) {
        // remove old counts
        oldPollData.checked.forEach(async value => {
            await decrement_count(constants.poll_path, value, "count");
        });
        // select new counts
        pollData.checked.forEach(async value => {
            await increment_count(constants.poll_path, value, "count");
        });
    }
};

export const set_rating = async (userId, trackId, ratingData) => {
    let data = await update_rating_data(userId, trackId, ratingData);
    await increment_count(constants.counts_path, trackId, constants.tracks_rating_count);
    return data;
};

export const update_track_listen_time = async (userId, trackId, listenTime, oldData) => {
    let newData = {
        listenTime: listenTime,
        timeStamp: Date.now(),
        ...oldData
    };
    await update_rating_data(userId, trackId, newData);
    await update_track_count(trackId, constants.tracks_stop_count);
};

// user methods
export const update_user = async (userId, userData) => {
    return await db.setItem(constants.users_path, userId, cleanUrls(userData));
};

const cleanUrls = userData => {
    // do deep clone first
    let updatedUserData = JSON.parse(JSON.stringify(userData));
    // clear out signed urls generated by aws
    updatedUserData.playlist.forEach(playlistEntry => {
        delete playlistEntry["artwork_url"];
        delete playlistEntry["song_url"];
    });
    return updatedUserData
};

export const fetch_user = async (userId) => {
    return await db.getItem(constants.users_path, userId);
};


export const fetch_reward_counts = async () => {
    let reward_count = await db.getItem(constants.counts_path, constants.reward_count);
    return reward_count.count;
};

export const increment_reward_count = async () => {
    await increment_count(constants.counts_path, constants.reward_count);
};

export const increment_count = async (table, id, path) => {
    let count = await db.getItem(table, id, path);
    db.updateItem(table, id, path, count + 1)
};

export const decrement_count = async (table, id, path) => {
    let count = await db.getItem(table, id, path);
    db.updateItem(table, id, path, count - 1)
};

// used to update track duration data, maybe remove later and replace with aws function
export const set_track = async (track) => {
    await db.setItem(constants.tracks_path, track.id, track);
};

